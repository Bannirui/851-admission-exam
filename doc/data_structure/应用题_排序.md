### 1 排序算法
序列{24,4,32,55,62,18,32*,39,13,35}，写出下列排序算法进行排序之后的序列状态。
(1) 直接插入排序
4,24,32,55,62,18,32*,39,13,35

从第二个元素开始抽取元素
把它与左边第一个元素比较 如果左边第一个元素比它大 则继续与左边第二个元素比较下去 直到遇到不比它大的元素 然后插入到这个元素右边
继续选择第3 4...n个元素重复

(2) 冒泡排序
4,24,32,55,18,32*,39,13,35,62

把第一个元素与第二个元素比较 如果第一个比第二个大则交换它们位置 接着继续比较第二个和第三个 如果第二个比第三个大则交换它们位置
对每一对相邻元素做同样工作 从开始的第一对到结尾的最后一对 这样一趟比较交换下来之后 排在最右的元素就会是最大的

(3) 快速排序
13,4,18,24,62,55,32*,39,32,35

(4) 简单选择排序
4,24,32,55,62,18,32*,39,13,35

找到最小的元素 跟第一个位置交换
其次 在剩余的元素找到最小的跟第二个位置交换

(5) 二路归并排序
4,24,32,55,16,62,32*,39,13,35

每一趟的结果
第1趟结果 [4,24] [32,55] [16,62] [32*,39] [13,35]
第2趟结果 [4,24,32,55] [16,32*,39,62] [13,35]
第3趟结果 [4,16,24,32,32*,39,55,62] [13,35]
第4趟结果 [4,13,16,24,32,32*,35,39,55,62]

### 2 小根堆
{6,5,4,3,2,1}利用数组建成一个最小堆并使用堆排序将其排序成唯一的降序数组。要画出所有中间过程。

### 3 归并排序
假设已经有k个长度分别为M0,M1...Mk-1的有序表，现通过两两合并的方式将它们合并为一个有序表，若要使合并过程中元素的总比较次数最小，应该按照什么次序进行合并？说明你的理由，必要时可以举例说明。

长为m和n的两个有序表合并，最坏情况下，关键字比较次数为m+n-1次。最坏情况下关键字对比次数依赖于两表的表长之和。因此每次合并时，应选表长最短的两个有序表进行合并，直到最终合并为一个为止，类似哈夫曼树的思想。